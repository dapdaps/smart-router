import { matcherHint, printExpected, printReceived } from 'jest-matcher-utils';
import spyMatchers from 'expect/build/spyMatchers';
import toThrowMatchers from 'expect/build/toThrowMatchers';

const printPass = () => () => `${matcherHint('.not.toBeAlwaysCalledOn', 'sinon.spy', 'obj')}\n\n` + `Expected spy to have ${printExpected('not always been called on obj')}, ` + `instead received a spy that has ${printReceived('always been called on obj')}`;

const printFail = () => () => `${matcherHint('.toBeAlwaysCalledOn', 'sinon.spy', 'obj')}\n\n` + `Expected spy to have ${printExpected('always been called on obj')}, ` + `instead received a spy that has ${printReceived('not always been called on obj')}`;

var toBeAlwaysCalledOn = ((expected, obj) => {
  return expected.alwaysCalledOn(obj) ? {
    pass: true,
    message: printPass()
  } : {
    pass: false,
    message: printFail()
  };
});

const printPass$1 = () => () => `${matcherHint('.not.toBeAlwaysCalledWith', 'sinon.spy', '')}\n\n` + `Expected spy to have ${printExpected('not been called with correct arguments')}, ` + `instead received a spy that has ${printReceived('been called with correct arguments')}`;

const printFail$1 = () => () => `${matcherHint('.toBeAlwaysCalledWith', 'sinon.spy', '')}\n\n` + `Expected spy to have ${printExpected('been called with correct arguments')}, ` + `instead received a spy that has ${printReceived('not been called with correct arguments')}`;

var toBeAlwaysCalledWith = ((expected, ...rest) => {
  return expected.alwaysCalledWith(...rest) ? {
    pass: true,
    message: printPass$1()
  } : {
    pass: false,
    message: printFail$1()
  };
});

const printPass$2 = () => () => `${matcherHint('.not.toBeAlwaysCalledWithExactly', 'sinon.spy', '')}\n\n` + `Expected spy to have ${printExpected('not been called with correct arguments')}, ` + `instead received a spy that has ${printReceived('been called with correct arguments')}`;

const printFail$2 = () => () => `${matcherHint('.toBeAlwaysCalledWithExactly', 'sinon.spy', '')}\n\n` + `Expected spy to have ${printExpected('been called with correct arguments')}, ` + `instead received a spy that has ${printReceived('not been called with correct arguments')}`;

var toBeAlwaysCalledWithExactly = ((expected, ...rest) => {
  return expected.alwaysCalledWithExactly(...rest) ? {
    pass: true,
    message: printPass$2()
  } : {
    pass: false,
    message: printFail$2()
  };
});

const printPass$3 = () => () => `${matcherHint('.not.toBeAlwaysCalledWithMatch', 'sinon.spy', '')}\n\n` + `Expected spy to have ${printExpected('not been called with correct arguments')}, ` + `instead received a spy that has ${printReceived('been called with correct arguments')}`;

const printFail$3 = () => () => `${matcherHint('.toBeAlwaysCalledWithMatch', 'sinon.spy', '')}\n\n` + `Expected spy to have ${printExpected('been called with correct arguments')}, ` + `instead received a spy that has ${printReceived('not been called with correct arguments')}`;

var toBeAlwaysCalledWithMatch = ((expected, ...rest) => {
  return expected.alwaysCalledWithMatch(...rest) ? {
    pass: true,
    message: printPass$3()
  } : {
    pass: false,
    message: printFail$3()
  };
});

const printPass$4 = () => () => `${matcherHint('.not.toBeAlwaysCalledWithNew', 'sinon.spy', '')}\n\n` + `Expected spy to have ${printExpected('not always been called with new')}, ` + `instead received a spy that has ${printReceived('always been called with new')}`;

const printFail$4 = () => () => `${matcherHint('.toBeAlwaysCalledWithNew', 'sinon.spy', '')}\n\n` + `Expected spy to have ${printExpected('always been called with new')}, ` + `instead received a spy that has ${printReceived('not always been called with new')}`;

var toBeAlwaysCalledWithNew = (expected => {
  return expected.alwaysCalledWithNew() ? {
    pass: true,
    message: printPass$4()
  } : {
    pass: false,
    message: printFail$4()
  };
});

var isSinonSpy = (potentialSpy => {
  return typeof potentialSpy.getCall === 'function' && typeof potentialSpy.alwaysCalledWithExactly === 'function' && typeof potentialSpy.alwaysReturned === 'function';
});

const printPass$5 = spy => () => `${matcherHint('.not.toBeCalled', 'sinon.spy', '')}\n\n` + `Expected spy to have ${printExpected('not been called')}, ` + `instead received a spy that has been called ${printReceived(spy.callCount)} time(s)`;

const printFail$5 = spy => () => `${matcherHint('.toBeCalled', 'sinon.spy', '')}\n\n` + `Expected spy to have ${printExpected('been called')}, ` + `instead received a spy that has been called ${printReceived(spy.callCount)} time(s)`;

var toBeCalled = (expected => {
  if (isSinonSpy(expected)) {
    return expected.called ? {
      pass: true,
      message: printPass$5(expected)
    } : {
      pass: false,
      message: printFail$5(expected)
    };
  }

  return spyMatchers.toHaveBeenCalled(expected);
});

const printPass$6 = () => () => `${matcherHint('.not.toBeCalledAfter', 'sinon.spy', 'sinon.spy')}\n\n` + `Expected spies to have ${printExpected('not been called in order')}`;

const printFail$6 = () => () => `${matcherHint('.toBeCalledAfter', 'sinon.spy', 'sinon.spy')}\n\n` + `Expected spies to have ${printExpected('been called in order')}`;

var toBeCalledAfter = ((expected, anotherSpy) => {
  return expected.calledAfter(anotherSpy) ? {
    pass: true,
    message: printPass$6()
  } : {
    pass: false,
    message: printFail$6()
  };
});

const printPass$7 = () => () => `${matcherHint('.not.toBeCalledBefore', 'sinon.spy', 'sinon.spy')}\n\n` + `Expected spies to have ${printExpected('not been called in order')}`;

const printFail$7 = () => () => `${matcherHint('.toBeCalledBefore', 'sinon.spy', 'sinon.spy')}\n\n` + `Expected spies to have ${printExpected('been called in order')}`;

var toBeCalledBefore = ((expected, anotherSpy) => {
  return expected.calledBefore(anotherSpy) ? {
    pass: true,
    message: printPass$7()
  } : {
    pass: false,
    message: printFail$7()
  };
});

const printPass$8 = () => () => `${matcherHint('.not.toBeCalledImmediatelyAfter', 'sinon.spy', 'sinon.spy')}\n\n Expected spies to have ${printExpected('not been called in order')}`;

const printFail$8 = () => () => `${matcherHint('.toBeCalledImmediatelyAfter', 'sinon.spy', 'sinon.spy')}\n\n Expected spies to have ${printExpected('been called in order')}`;

var toBeCalledImmediatelyAfter = ((expected, anotherSpy) => {
  return expected.calledImmediatelyAfter(anotherSpy) ? {
    pass: true,
    message: printPass$8()
  } : {
    pass: false,
    message: printFail$8()
  };
});

const printPass$9 = () => () => `${matcherHint('.not.toBeCalledImmediatelyBefore', 'sinon.spy', 'sinon.spy')}\n\n Expected spies to have ${printExpected('not been called in order')}`;

const printFail$9 = () => () => `${matcherHint('.toBeCalledImmediatelyBefore', 'sinon.spy', 'sinon.spy')}\n\n Expected spies to have ${printExpected('been called in order')}`;

var toBeCalledImmediatelyBefore = ((expected, anotherSpy) => {
  return expected.calledImmediatelyBefore(anotherSpy) ? {
    pass: true,
    message: printPass$9()
  } : {
    pass: false,
    message: printFail$9()
  };
});

const printPass$a = () => () => `${matcherHint('.not.toBeCalledOn', 'sinon.spy', 'obj')}\n\n` + `Expected spy to have ${printExpected('not been called on obj')}, ` + `instead received a spy that has ${printReceived('been called on obj')}`;

const printFail$a = () => () => `${matcherHint('.toBeCalledOn', 'sinon.spy', 'obj')}\n\n` + `Expected spy to have ${printExpected('been called on obj')}, ` + `instead received a spy that has ${printReceived('been called on obj')}`;

var toBeCalledOn = ((expected, obj) => {
  return expected.calledOn(obj) ? {
    pass: true,
    message: printPass$a()
  } : {
    pass: false,
    message: printFail$a()
  };
});

const printPass$b = spy => () => `${matcherHint('.not.toBeCalledOnce', 'sinon.spy', '')}\n\n` + `Expected spy to have ${printExpected('not been called once')}, ` + `instead received a spy that has been called ${printReceived(spy.callCount)} time(s)`;

const printFail$b = spy => () => `${matcherHint('.toBeCalledOnce', 'sinon.spy', '')}\n\n` + `Expected spy to have ${printExpected('been called once')}, ` + `instead received a spy that has been called ${printReceived(spy.callCount)} time(s)`;

var toBeCalledOnce = (expected => {
  return expected.calledOnce ? {
    pass: true,
    message: printPass$b(expected)
  } : {
    pass: false,
    message: printFail$b(expected)
  };
});

const printPass$c = () => () => `${matcherHint('.not.toBeCalledOnceWith', 'sinon.spy', '')}\n\n` + `Expected spy to have ${printExpected('not been called with correct arguments')}, ` + `instead received a spy that has ${printReceived('been called with correct arguments')}`;

const printFail$c = () => () => `${matcherHint('.toBeCalledOnceWith', 'sinon.spy', '')}\n\n` + `Expected spy to have ${printExpected('been called with correct arguments')}, ` + `instead received a spy that has ${printReceived('not been called with correct arguments')}`;

var toBeCalledOnceWith = ((expected, ...rest) => {
  return expected.calledOnceWith(...rest) ? {
    pass: true,
    message: printPass$c()
  } : {
    pass: false,
    message: printFail$c()
  };
});

const printPass$d = () => () => `${matcherHint('.not.toBeCalledOnceWithExactly', 'sinon.spy', 'obj')}\n\n` + `Expected spy to have ${printExpected('not been called with correct arguments')}, ` + `instead received a spy that has ${printReceived('been called with correct arguments')}`;

const printFail$d = () => () => `${matcherHint('.toBeCalledOnceWithExactly', 'sinon.spy', 'obj')}\n\n` + `Expected spy to have ${printExpected('been called with correct arguments')}, ` + `instead received a spy that has ${printReceived('not been called with correct arguments')}`;

var toBeCalledOnceWithExactly = ((expected, ...rest) => {
  return expected.calledOnceWithExactly(...rest) ? {
    pass: true,
    message: printPass$d()
  } : {
    pass: false,
    message: printFail$d()
  };
});

const printPass$e = spy => () => `${matcherHint('.not.toBeCalledThrice', 'sinon.spy', '')}\n\n` + `Expected spy to have ${printExpected('not been called thrice')}, ` + `instead received a spy that has been called ${printReceived(spy.callCount)} time(s)`;

const printFail$e = spy => () => `${matcherHint('.toBeCalledThrice', 'sinon.spy', '')}\n\n` + `Expected spy to have ${printExpected('been called thrice')}, ` + `instead received a spy that has been called ${printReceived(spy.callCount)} time(s)`;

var toBeCalledThrice = (expected => {
  return expected.calledThrice ? {
    pass: true,
    message: printPass$e(expected)
  } : {
    pass: false,
    message: printFail$e(expected)
  };
});

const printPass$f = spy => () => `${matcherHint('.not.toBeCalledTwice', 'sinon.spy', '')}\n\n` + `Expected spy to have ${printExpected('not been called twice')}, ` + `instead received a spy that has been called ${printReceived(spy.callCount)} time(s)`;

const printFail$f = spy => () => `${matcherHint('.toBeCalledTwice', 'sinon.spy', '')}\n\n` + `Expected spy to have ${printExpected('been called twice')}, ` + `instead received a spy that has been called ${printReceived(spy.callCount)} time(s)`;

var toBeCalledTwice = (expected => {
  return expected.calledTwice ? {
    pass: true,
    message: printPass$f(expected)
  } : {
    pass: false,
    message: printFail$f(expected)
  };
});

const printPass$g = () => () => `${matcherHint('.not.toBeCalledWith', 'sinon.spy', '')}\n\n` + `Expected spy to have ${printExpected('not been called with correct arguments')}, ` + `instead received a spy that has ${printReceived('been called with correct arguments')}`;

const printFail$g = () => () => `${matcherHint('.toBeCalledWith', 'sinon.spy', '')}\n\n` + `Expected spy to have ${printExpected('been called with correct arguments')}, ` + `instead received a spy that has ${printReceived('not been called with correct arguments')}`;

var toBeCalledWith = ((expected, ...rest) => {
  if (isSinonSpy(expected)) {
    return expected.calledWith(...rest) ? {
      pass: true,
      message: printPass$g()
    } : {
      pass: false,
      message: printFail$g()
    };
  }

  return spyMatchers.toHaveBeenCalledWith(expected, ...rest);
});

const printPass$h = () => () => `${matcherHint('.not.toBeCalledWithExactly', 'sinon.spy', '')}\n\n` + `Expected spy to have ${printExpected('not been called with correct arguments')}, ` + `instead received a spy that has ${printReceived('been called with correct arguments')}`;

const printFail$h = () => () => `${matcherHint('.toBeCalledWithExactly', 'sinon.spy', '')}\n\n` + `Expected spy to have ${printExpected('been called with correct arguments')}, ` + `instead received a spy that has ${printReceived('not been called with correct arguments')}`;

var toBeCalledWithExactly = ((expected, ...rest) => {
  return expected.calledWithExactly(...rest) ? {
    pass: true,
    message: printPass$h()
  } : {
    pass: false,
    message: printFail$h()
  };
});

const printPass$i = () => () => `${matcherHint('.not.toBeCalledWithMatch', 'sinon.spy', '')}\n\n` + `Expected spy to have ${printExpected('not been called with correct arguments')}, ` + `instead received a spy that has ${printReceived('been called with correct arguments')}`;

const printFail$i = () => () => `${matcherHint('.toBeCalledWithMatch', 'sinon.spy', '')}\n\n` + `Expected spy to have ${printExpected('been called with correct arguments')}, ` + `instead received a spy that has ${printReceived('not been called with correct arguments')}`;

var toBeCalledWithMatch = ((expected, ...rest) => {
  return expected.calledWithMatch(...rest) ? {
    pass: true,
    message: printPass$i()
  } : {
    pass: false,
    message: printFail$i()
  };
});

const printPass$j = () => () => `${matcherHint('.not.toBeCalledWithNew', 'sinon.spy', '')}\n\n` + `Expected spy to have ${printExpected('not been called with new')}, ` + `instead received a spy that has ${printReceived('been called with new')}`;

const printFail$j = () => () => `${matcherHint('.toBeCalledWithNew', 'sinon.spy', '')}\n\n` + `Expected spy to have ${printExpected('been called with new')}, ` + `instead received a spy that has ${printReceived('not been called with new')}`;

var toBeCalledWithNew = (expected => {
  return expected.calledWithNew() ? {
    pass: true,
    message: printPass$j()
  } : {
    pass: false,
    message: printFail$j()
  };
});

const printPass$k = (expected, actual) => () => `${matcherHint('.not.toHaveCallCount', 'sinon.spy', 'callCount')}\n\n` + `Expected spy to have not been called ${printExpected(expected)} time(s), ` + `instead received a spy that has been called ${printReceived(actual.callCount)} time(s)`;

const printFail$k = (expected, actual) => () => `${matcherHint('.toHaveCallCount', 'sinon.spy', 'callCount')}\n\n` + `Expected spy to have been called ${printExpected(expected)} time(s), ` + `instead received a spy that has been called ${printReceived(actual.callCount)} time(s)`;

var toHaveCallCount = ((actual, expected) => {
  if (isSinonSpy(actual)) {
    return expected === actual.callCount ? {
      pass: true,
      message: printPass$k(expected, actual)
    } : {
      pass: false,
      message: printFail$k(expected, actual)
    };
  }

  return spyMatchers.toHaveBeenCalledTimes(actual, expected);
});

const printPass$l = () => () => `${matcherHint('.not.toHaveReturnedWith', 'sinon.spy', 'obj')}\n\n` + `Expected spy to have ${printExpected('not returned obj')}, ` + `instead received a spy that has ${printReceived('returned obj')}`;

const printFail$l = () => () => `${matcherHint('.toHaveReturnedWith', 'sinon.spy', 'obj')}\n\n` + `Expected spy to have ${printExpected('been returned obj')}, ` + `instead received a spy that has ${printReceived('not returned obj')}`;

var toHaveReturnedWith = ((expected, obj) => {
  if (isSinonSpy(expected)) {
    return expected.returned(obj) ? {
      pass: true,
      message: printPass$l()
    } : {
      pass: false,
      message: printFail$l()
    };
  }

  return spyMatchers.toReturnWith(expected, obj);
});

const printPass$m = () => () => `${matcherHint('.not.toHaveAlwaysReturnedWith', 'sinon.spy', 'obj')}\n\n` + `Expected spy to have ${printExpected('not returned obj')}, ` + `instead received a spy that has ${printReceived('returned obj')}`;

const printFail$m = () => () => `${matcherHint('.toHaveAlwaysReturnedWith', 'sinon.spy', 'obj')}\n\n` + `Expected spy to have ${printExpected('been returned obj')}, ` + `instead received a spy that has ${printReceived('not returned obj')}`;

var toHaveAlwaysReturnedWith = ((expected, obj) => {
  return expected.alwaysReturned(obj) ? {
    pass: true,
    message: printPass$m()
  } : {
    pass: false,
    message: printFail$m()
  };
});

const printPass$n = () => () => `${matcherHint('.not.toHaveThrown', 'sinon.spy', 'TypeError | obj')}\n\n` + `Expected spy to have ${printExpected('not thrown an error')}, ` + `instead received a spy that has ${printReceived('thrown an error')}`;

const printFail$n = () => () => `${matcherHint('.toHaveThrown', 'sinon.spy', 'TypeError | obj')}\n\n` + `Expected spy to have ${printExpected('thrown an error')}, ` + `instead received a spy that has ${printReceived('not thrown an error')}`;

var toHaveThrown = ((expected, errorObjOrErrorTypeStringOrNothing) => {
  if (isSinonSpy(expected)) {
    return expected.threw(errorObjOrErrorTypeStringOrNothing) ? {
      pass: true,
      message: printPass$n()
    } : {
      pass: false,
      message: printFail$n()
    };
  }

  return toThrowMatchers.toThrow(expected, errorObjOrErrorTypeStringOrNothing);
});

const printPass$o = () => () => `${matcherHint('.not.toHaveAlwaysThrown', 'sinon.spy', 'TypeError | obj')}\n\n` + `Expected spy to have ${printExpected('not thrown an error')}, ` + `instead received a spy that has ${printReceived('thrown an error')}`;

const printFail$o = () => () => `${matcherHint('.toHaveAlwaysThrown', 'sinon.spy', 'TypeError | obj')}\n\n` + `Expected spy to have ${printExpected('thrown an error')}, ` + `instead received a spy that has ${printReceived('not thrown an error')}`;

var toHaveAlwaysThrown = ((expected, errorObjOrErrorTypeStringOrNothing) => {
  return expected.alwaysThrew(errorObjOrErrorTypeStringOrNothing) ? {
    pass: true,
    message: printPass$o()
  } : {
    pass: false,
    message: printFail$o()
  };
});

var matchers = /*#__PURE__*/Object.freeze({
  __proto__: null,
  toBeAlwaysCalledOn: toBeAlwaysCalledOn,
  toHaveBeenAlwaysCalledOn: toBeAlwaysCalledOn,
  toBeAlwaysCalledWith: toBeAlwaysCalledWith,
  toHaveBeenAlwaysCalledWith: toBeAlwaysCalledWith,
  toBeAlwaysCalledWithExactly: toBeAlwaysCalledWithExactly,
  toHaveBeenAlwaysCalledWithExactly: toBeAlwaysCalledWithExactly,
  toBeAlwaysCalledWithMatch: toBeAlwaysCalledWithMatch,
  toHaveBeenAlwaysCalledWithMatch: toBeAlwaysCalledWithMatch,
  toBeAlwaysCalledWithNew: toBeAlwaysCalledWithNew,
  toHaveBeenAlwaysCalledWithNew: toBeAlwaysCalledWithNew,
  toBeCalled: toBeCalled,
  toHaveBeenCalled: toBeCalled,
  toBeCalledAfter: toBeCalledAfter,
  toHaveBeenCalledAfter: toBeCalledAfter,
  toBeCalledBefore: toBeCalledBefore,
  toHaveBeenCalledBefore: toBeCalledBefore,
  toHaveBeenCalledImmediatelyAfter: toBeCalledImmediatelyAfter,
  toBeCalledImmediatelyAfter: toBeCalledImmediatelyAfter,
  toBeCalledImmediatelyBefore: toBeCalledImmediatelyBefore,
  toHaveBeenCalledImmediatelyBefore: toBeCalledImmediatelyBefore,
  toBeCalledOn: toBeCalledOn,
  toHaveBeenCalledOn: toBeCalledOn,
  toBeCalledOnce: toBeCalledOnce,
  toHaveBeenCalledOnce: toBeCalledOnce,
  toBeCalledOnceWith: toBeCalledOnceWith,
  toHaveBeenCalledOnceWith: toBeCalledOnceWith,
  toBeCalledOnceWithExactly: toBeCalledOnceWithExactly,
  toHaveBeenCalledOnceWithExactly: toBeCalledOnceWithExactly,
  toBeCalledThrice: toBeCalledThrice,
  toHaveBeenCalledThrice: toBeCalledThrice,
  toBeCalledTwice: toBeCalledTwice,
  toHaveBeenCalledTwice: toBeCalledTwice,
  toBeCalledWith: toBeCalledWith,
  toHaveBeenCalledWith: toBeCalledWith,
  toBeCalledWithExactly: toBeCalledWithExactly,
  toHaveBeenCalledWithExactly: toBeCalledWithExactly,
  toBeCalledWithMatch: toBeCalledWithMatch,
  toHaveBeenCalledWithMatch: toBeCalledWithMatch,
  toBeCalledWithNew: toBeCalledWithNew,
  toHaveBeenCalledWithNew: toBeCalledWithNew,
  toHaveCallCount: toHaveCallCount,
  toHaveBeenCalledTimes: toHaveCallCount,
  toBeCalledTimes: toHaveCallCount,
  toHaveReturnedWith: toHaveReturnedWith,
  toReturnWith: toHaveReturnedWith,
  toHaveReturned: toHaveReturnedWith,
  toReturn: toHaveReturnedWith,
  toHaveAlwaysReturnedWith: toHaveAlwaysReturnedWith,
  toAlwaysReturnWith: toHaveAlwaysReturnedWith,
  toHaveThrown: toHaveThrown,
  toHaveThrownError: toHaveThrown,
  toThrow: toHaveThrown,
  toThrowError: toHaveThrown,
  toHaveAlwaysThrown: toHaveAlwaysThrown,
  toHaveAlwaysThrownError: toHaveAlwaysThrown,
  toAlwaysThrow: toHaveAlwaysThrown,
  toAlwaysThrowError: toHaveAlwaysThrown
});

/* eslint-disable no-console */
const jestExpect = global.expect;

if (jestExpect !== undefined) {
  jestExpect.extend(matchers);
} else {
  console.error("Unable to find Jest's global expect");
}
