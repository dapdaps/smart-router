"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
require("setimmediate");
const hardhat_1 = __importDefault(require("hardhat"));
const task_names_1 = require("hardhat/builtin-tasks/task-names");
const constants_1 = require("hardhat/internal/constants");
const accounts_1 = require("./accounts");
const hardhat_2 = require("./hardhat");
/**
 * Use this setup function to subclass your own jest environment.
 *
 * @example
 * import NodeEnvironment from 'jest-environment-node'
 * import setup from 'jest-environment-hardhat/setup'
 * export default class HardhatNodeEnvironment extends NodeEnvironment {
 *   _teardown: Awaited<ReturnType<typeof setup>> = () => Promise.resolve()
 *   async setup() {
 *     await super.setup()
 *     this._teardown = await setup()
 *     this.global.hardhat = hardhat
 *   }
 *   async teardown() {
 *     await this._teardown()
 *     await super.teardown()
 *   }
 * }
 *
 * @returns teardown
 */
function setup() {
    return __awaiter(this, void 0, void 0, function* () {
        if (!hardhat_1.default.ethers) {
            throw new Error('`jest-environment-hardhat` requires the `@nomiclabs/hardhat-ethers` plugin to be installed.\nSee https://hardhat.org/plugins/nomiclabs-hardhat-ethers.html#hardhat-ethers.');
        }
        if (!hardhat_1.default.config.networks.hardhat.forking) {
            throw new Error('`forking` must be specified to use `jest-environment-hardhat`.\nSee https://hardhat.org/hardhat-network/guides/mainnet-forking.html#mainnet-forking.');
        }
        // Overrides the GET_PROVIDER task to avoid unnecessary time-intensive evm calls.
        hardhat_1.default.tasks[task_names_1.TASK_NODE_GET_PROVIDER].setAction(() => __awaiter(this, void 0, void 0, function* () { return hardhat_1.default.network.provider; }));
        const id = Number(process.env.JEST_WORKER_ID);
        const port = 8545 + (Number.isNaN(id) ? 0 : id);
        const run = hardhat_1.default.run(task_names_1.TASK_NODE, { port });
        const serverReady = new Promise((resolve) => hardhat_1.default.tasks[task_names_1.TASK_NODE_SERVER_READY].setAction(({ address, port, server }) => __awaiter(this, void 0, void 0, function* () {
            const url = 'http://' + address + ':' + port;
            resolve({ url, server });
        })));
        // Deriving ExternallyOwnedAccounts is computationally intensive, so it is done while waiting for the server to come up.
        const wallets = (0, accounts_1.toExternallyOwnedAccounts)(hardhat_1.default.network.config.accounts);
        if (wallets.length > 4) {
            process.stderr.write(`${wallets.length} hardhat accounts specified - consider specifying fewer.\n`);
            process.stderr.write('Specifying multiple hardhat accounts will noticeably slow your test startup time.\n\n');
        }
        const { url, server } = yield serverReady;
        globalThis.hardhat = new hardhat_2.Hardhat(hardhat_1.default, url, wallets);
        // Enables hardhat logging if --verbose was passed.
        if (hardhat_1.default.config.networks.hardhat.loggingEnabled || process.argv.includes('--verbose')) {
            yield hardhat_1.default.network.provider.send('hardhat_setLoggingEnabled', [true]);
        }
        hardhat_1.default.network.provider.prependListener(constants_1.HARDHAT_NETWORK_RESET_EVENT, () => resetJsonRpcProvider(hardhat_1.default.ethers.provider));
        hardhat_1.default.network.provider.prependListener(constants_1.HARDHAT_NETWORK_REVERT_SNAPSHOT_EVENT, () => resetJsonRpcProvider(hardhat_1.default.ethers.provider));
        return () => __awaiter(this, void 0, void 0, function* () {
            resetJsonRpcProvider(hardhat_1.default.ethers.provider);
            yield server.close();
            yield run;
        });
    });
}
exports.default = setup;
/** Prevents a JsonRpcProvider from continuing to run its internal timers. */
function resetJsonRpcProvider(provider) {
    clearTimeout(provider._bootstrapPoll);
    provider.removeAllListeners();
}
